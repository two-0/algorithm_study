## 👨🏻‍💻 **들어가며**

### **Linked List 란**

- 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료 구조이다.
- 이름에서 말하듯이 데이터를 담고 있는 노드들이 연결되어 있는데 노드의 포인터가 다음이나 이전의 노드와의 연결을 담당하게 된다.

<br>

### **종류**

- 단일 연결 리스트
- 이중 연결 리스트
- 원형 연결 리스트

<br>

### **연결 리스트의 등장 배경**

- 사실상 오늘 날의 컴퓨터는 엄청난 발전으로 인해 연결리스트 기술에 대한 필요도를 그다지 느끼지 못한다.
- 하지만 아직 컴퓨터가 급격하기 발전하기 이전의 컴퓨터는 메모리를 사용함에 있어 1bit 1bit 까지 소중하게 여겼다.
- 배열은 여기서 엄청난 단점을 가지고 있는데 가변적인 데이터 즉, 배열을 생성할 때 정확한 크기를 알 수 없다면 임의로 넉넉한 양을 정하고 배열을 생성해야 한다는 것이다. 하지만 배열의 크기만큼 데이터를 사용하면 다행이지만 그렇지 못할 경우 컴퓨터의 메모리를 낭비하는 비효율적인 방법이었다.
- **연결 리스트는 이러한 단점을 극복하고자 등장하게 된 자료구조 이다.**

<br>

## **장점**

- 링크로써 구현이 되기 때문에 데이터를 추가하거나 삭제할 시 링크가 가르키는 주소만 변경하면 되기 때문에 추가, 삭제가 용이하다,
- 메모리 효율성이 우수하다.
- 필요할 때마다 데이터 추가, 삭제가 가능하기 때문에 배열 처럼 최대 원소 개수를 지정할 필요가 없다.

<br>

## **단점**

- 원하는 원소를 찾을 때까지 포인터로 노드를 탐색하기 때문에 탐색 비용이 높다.
- 구현이 복잡하다.

<br>

## **정리**

- 탐색 비용이 많이 드는 연결 리스트는 탐색을 해야하는 로직에서 사용하는 것은 바람직하지 않다.
- 데이터의 추가와 삭제 등의 변경이 자주 발생하는 로직에서 사용하는 것이 바람직하다.

<br><br>

## **구현하기**

- 본래 연결리스트는 C언의 꽃이라고 필자는 생각한다. 하지만 필자는 코딩 테스트를 위한 알고리즘 공부이기 때문에 파이썬으로 구현한다.
- 파이썬은 이미 리스트에서 상당한 이점을 가지고 가기 때문에 안그래도 복잡한 연결 리스트 구현을 C언어 보다 훨씬 간단하게 구현할 수 있다.
- 추가적으로 객체지향적 코딩을 하기에도 객체지향 언어를 선택하는 것이 바람직하며 성능 이슈에 대한 부분도 논란이 될까 라는 의문이 든다.
- 애초에 탐색을 자주하는 로직에 연결리스트를 사용하는 것은 바람직하지 않다. 단순 입력, 삭제, 변경을 위한 로직에는 고성능의 C언어 와 같은 저수준의 언어는 필요없다.
- 이와 같은 방식은 현재 많은 기업에서 채택하고 있다고 한다. 머신러닝 등 데이터를 읽고 찾는 것에는 C언어가 많이 사용되지만 단순 기능 제공에는 파이썬과 같은 하이레벨의 언어를 많이 사용한다.

<br>

### **01. Node 생성**

```python
# 연결 리스트 구현을 위한 노드 구현
class Node:
    def __init__(self, data, next=None):
        self.data = data
        self.next = next
```

- 객체지향 관점에서 Node 구현은 간단하다. 생성 함과 동시에 data와 주소를 담는 next라는 메모리를 할당하면 된다.

<br><br>

### **02. 연결리스트 구현을 위한 NodeManageMent 구현하기**

```python
# 객체지향적 연결 리스트 구현
class NodeMgmt:
    def __init__(self, data):
        # 생성과 동시에 head를 만들어 준다. <<< head 가 Null이 되는 것을 방지한다.
        self.head = Node(data)

    # 데이터 추가를 위한 함수
    def add(self, data):
        node = self.head
        while node.next:
            node = node.next
        node.next = Node(data)

    # 데이터 확인을 위한 함수
    def desc(self):
        node = self.head  # 데이터 출력을 위해선 head를 알아야 한다. head 는 init에서 제공한다.
        while node:
            print(node.data)
            node = node.next

    def delete(self, data):
        # 헤드 값이 없을 때
        if self.head == '':
            print("해당 값을 가진 노드가 없습니다.")
            return

	# 지우는 값이 헤드 값 일때
        if self.head.data == data:
            temp = self.head
            self.head = self.head.next
            del temp
        else:
	# 지우는 값이 중간값 일 때
            node = self.head
            while node.next:
                if node.next.data == data:
                    temp = node.next
                    node.next = node.next.next
                    del temp
                    return
                else:
                    node = node.next

```

<br><br>

### **분석하기**

**`def add()`**

- 먼저 add () 함수이다. 노드를 추가하는 함수이며 구현이 간단하다 먼저 NodeManageMent 객체를 생성하는 순간 head 값도 생성되기 때문에 특별히 head 객체를 생성할 필요는 없다.
- 그리고 이 head 노드를 node 라는 객체로 새롭게 할당 한다. 그렇다면 node 객체가 head가 된다.
- 이제 head가 정해졌으니 while 문을 통해 순회하게 되는데 node.next가 None 이 아닐 때까지 즉, 다음 데이터가 있는 경우 쭉 순회하고 마지막 노드에 도착해서 node.next 가 None 인 곧에서 while 문은 종료되고 next 에 새로운 Node(data)를 할당하게 된다.

**`def desc()`**

- 해당 함수는 단순히 지금 연결 리스트의 데이터 상태를 보기 위한 함수로 별다른 로직이 없다. add 와 마찬가지로 node에 head 값을 준다 (그래야 첫 번째 Node 부터 순회할 수 있으니) 그리고 node.next가 true일 때 동안 계속 순회하며 데이터를 찍는다.
- 여기서 데이터를 찍고 난뒤 다음 데이터로 이동하도록 하는 부분이 젤 마지막 코드에 `node = node.next` 이렇게 들어오는데 이 부분만 주의하자.
- 해당 코드가 없다면 다음 코드로 이동하지 못하기 때문이다.

`def delete()`

- 개인적으로 단일 연결리스트 구현에서 가장 신경을 써야하는 부분이라고 생각한다. 우선 생각 해야할 부분을 정리 해보면 아래와 같다.

1. 헤드가 없을 경우
2. 지우는 값이 헤드 일 경우
3. 지우는 값이 중간일 경우

<br>

**먼저 헤드가 없는 경우 부터 분기처리한다**.

- 그 이유는 헤드가 없다면 애초에 시작이 안되기 때문이다.
- 헤드가 없는 경우는 간단하다. self.head에 아무 값이 없다면 헤드가 없는 경우다. 따라서 간단하게 구현 가능하다.

<br>

**두 번째 지우는 값이 헤드일 경우에 대한 분기처리이다.**

- 지우는 값이 헤드일 경우 임시 변수에 현재 헤드 Node를 잠시 복사 해둔다.
- 그리고 본래의 self.head 노드에 본래 두 번째에 있던 node를 땡겨 온다.
- 이렇게 되면 본래 head는 삭제되고 임시 변수에 head가 복제된 상태로 존재하게 되는데 마무리로 이 복제된 head를 삭제하면 된다.

<br>

**마지막으로 지우는 값이 중간 값일 경우에 대한 분기처리이다.**

- 우선 지우고자 하는 node를 찾아야 하기 때문에 head 를 할당 받아 해당 데이터가 지우고자 하는 데이터와 같을 때 까지 순회한다. 단 node.next가 존재할 때 까지
- node.next가 false 인데도 지우고자 하는 Node를 찾지 못했다면 단순히 next에 해당

- 이제 node를 순회 하다 보니 삭제할 data가 현재 node.next가 가지고 있는 data와 동일한 경우가 되었다. >>> `node.next.data == data`
- 그렇다면 문저 node.next를 추후 지우기 위해 temp 라는 임시변수에 할당해둔다.
- **그리고 node.next 에는 node.next.next 가 들어오게 된다.**

<br>

`node.next = node.next.next`

- 이 부분이 상당히 주의를 해야하는 부분인데 먼저 노드 1 , 노드 2, 노드 3번 이 있고 노드 2번이 삭제되어야 할 경우라고 가정하겠다.
- 지금 분기 처리가 된 상황은 노드 1이 가르키는 next의 데이터가 삭제할 data인 경우에 분기가 되었기 때문에 현재 노드는 노드 1번이다. 이제 여기서 노드 2번을 삭제하고 노드 3번이랑 연결해야 하기 때문에
- **노드 1번의 next에는 노드2번의 next 즉 >>>> node.next.next가 와야 한다.**
- 그리고 임시적으로 복제 해놓은 노드 2번은 del 을 통해 삭제한다. 이 과정을 통해 중간 값 노드를 삭제할 수 있게된다.
