모든 출처는 아래의 책에서 참고 되었습니다.
<br>

![](https://images.velog.io/images/somday/post/45cb01a0-0ac0-4030-be4c-99d16aa14eea/%EC%9D%B4%EA%B2%83%EC%9D%B4%20%EC%BD%94%EB%94%A9%20%ED%85%8C%EC%8A%A4%EB%93%9C%EB%8B%A4.jpg)

<br> <br>

## 당장 좋은 것만 선택하는 그리디

- 그리디 알고리즘은 단순하지만 강력한 문제 해결 방법입니다. 이 알고리즘은 다른 말고 **"탐욕법" 이라고도 합니다.**
- 이름에서 알 수 있듯이 어떠한 문제가 있을 때 단순하게, 탐욕적으로 문제를 푸는 알고리즘 입니다.
- 여기서 탐욕적이란 것은 현재 상황에서 지금 당장 좋은 것만 고르믄 방법을 의미 합니다.
- 그리디 알고리즘을 이용하면 매 순간 가장 좋아보이는 것을 선택하며, 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않습니다.

그리디 알고리즘은 기준에 따라 좋은 것을 선택하는 알고리즘이므로 문제에서 '가장 큰 순서대로', '가장 작은 순서대로'와 같은 기준을 알게 모르게 제시해줍니다. 그리고 이 기준은 정렬 알고리즘을 사용할 경우 만족시킬 수 있기 때문에 그리디 알고리즘 문제는 자주 정렬 알고리즘과 함께 출시 됩니다.

<br>

## 대표 유형 - 거스름돈

- 거스름돈 문제는 대표적인 그리디 알고리즘 문제 입니다. 예제를 보며 그리디 알고리즘을 보다 학습하겠습니다.

<br>

**문제**

카운터에 거스름돈이 500원 100원 50원 10원이 무한히 존재하는데 손님에게 거슬러 줘야 할 돈이 N원일 때 거슬러줘야 할 동전의 **최소 개수**를 구하여라 (단 거슬러 줘야 할 돈 N은 항상 10의 배수 입니다.)

<br>

**해설**

- 이 문제는 그리디 알고리즘을 이용해 풀 수 있는 대표적인 문제로 간단한 아이디어만 떠올릴 수 있다면 쉽게 풀 수 있습니다.
- 그 아이디어는 **바로 가장 큰 화폐 단위부터 돈을 거슬러 주는 것 입니다.**

<br>

**코드**

```python
money = int(input("거스름돈은 얼마인가요: "))

count = 0

coin_types = [500, 100, 50 ,10]

for coin in coin_types:
    count += money // coin
    money %= coin

print(count)
```

**설명**

- 이 문제는 for 문을 통해 거스름돈을 최대값 동전으로 나누면 최대값 동전으로 지불할 수 있는 카운트가 나옵니다.
- 그리고 다시 금액은 최대값 동전으로 나누고 남은 가격으로 업데이트 해줍니다.
- 즉, 거스름돈이 1260원 일 때 첫번째 for문에서 500원짜리고 2번을 낼 수 있는데 이를 코드로 나타내면 `count = count + money // coin` 와 같습니다.
- 그리고 아래 `money %= coin` 으로 최대값 코인으로 돈을 지불하고 남은 금액을 구해서 또 다음 최대값 코인으로 위의 과정을 반복 합니다.

이렇게 로직을 거치게 되면 거스름돈이 1260원일 경우 최소의 동전으로 6개의 동전이 필요하게 됩니다.

<br>

**시간 복잡도**

- 코드를 보면 화폐의 종류만큼 반복을 수행해야 합니다. 따라서 화폐의 종류가 K개 라고 가정한다면 해당 코드의 시간 복잡도는 O(K) 가 됩니다.
- 해당 알고리즘에서 주의할 점은 시간복잡도에 거스름돈 N의 크기는 전혀 영향을 미치지 않는다는 것 입니다. **따라서 이 알고리즘의 시간 복잡도는 동전의 총 종류에만 영향을 받고 거슬러 줘야하는 금액의 크기와는 무관하다는 것을 알 수 있습니다.**

<br>

## **그리디 알고리즘의 정당성**

- 그리디 알고리즘의 한계는 모든 문제에 위와 같은 알고리즘을 적용할 수 없다는 점입니다. 그 이유는 대부분의 문제는 그리디를 사용할 경우 **'최적의 해'**를 찾이 못할 가능성이 다분하기 때문 입니다.
- 하지만 거스름돈 문제는 '가장 큰 화폐 단위부터" 돈을 거슬러 주는 것 처럼 **탐욕적 접근 방법이 최적의 해를 보장할 수 있을 경우 매우 효과적인 방법 입니다.**
- 따라서 그리디 알고리즘으로 문제의 해법을 찾을 때는 그 해법이 정단한지 검토해야 하며, 거스름돈 문제를 그리디 알고리즘으로 해결할 수 있는 이유는 **"가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문 입니다."**

<br>

### 최적의 해가 아닌 경우

만약 800원을 거슬러 주는 상황인데 화폐 단위가 [500, 400, 100] 이라고 가정해보겠습니다. 이럴 때 위의 알고리즘 대로 적용을 한다면 (500, 100, 100, 100) 이 적용되어 총4개의 동전을 소모하는데

그의 반해 최적의 해는 400 x 2으로 해결하는 총 2개의 코인 수가 최적의 해가 됩니다. 이처럼 코인 타입이 서로의 배수의 관계가 아니라면 위의 알고리즘을 적용하면 최적의 해를 구할 수 없습니다. 따라서 그리디 알고리즘을 적용하기 위해선 최적의 해가 되는지에 대한 고민이 많이 필요로 가게 됩니다.

<br>

### 내가 생각한 접근 방식

- 먼저 거스름돈 화페가 서로 배수의 관계인지 확인다.
- 문제 유형 파악이 힘든 경우 그리디를 의심하고 처음에는 최소 값으로 최적의 해가 되는지 판별하고 화폐 단위를 올려가는 방식으로 생각한다.
- 화폐 단위가 무작위일 경우 다이나믹 프로그래밍을 적용한다.

<br> <br>

## 실전 문제 - 큰 수의 법칙

 <br>

**문제**

여기서 큰 수의 법칙이란 다양한 수로 이뤄진 배열이 있을 때 주어진 수들을 M번 더해 가장 큰 수를 만드는 법칙

단, 배열의 특정한 인덱스(번호)에 해당하는 수가 연속해서 K번을 초과할 수는 없음

 <br>

**입력 조건**

첫째 줄에 N(2<=N<=1000), M(1<=M<=10000), K(1<=K<=10000)의 자연수가 주어지며 각 자연수는 공백으로 구분

둘째줄에 N개의 자연수가 주어짐. 각 자연수는 공백으로 구분. 단, 각각의 자연수는 1이상 10000이하의 수로 주어짐

입력으로 주어지는 K는 항상 M보다 작거나 같다.

 <br>

**출력 조건**

첫째 줄에 큰 수의 법칙에 따라 더해진 답을 출력

 <br>

**입력 예시**

5 8 3

2 4 5 4 6

 <br>

**출력 예시**

46

 <br>

**code**

```python
# 문제:  큰 수의 법칙
# n: 배열의 크기
# m: 숫자가 더해지는 횟수
# k: 반복해서 더 할 수 있는 최대 횟수

n, m, k = map(int,input().split())
data = list(map(int, input().split()))

# 오름차순 정렬
data.sort()
first = data[n - 1]
second = data[n - 2]
result = 0

while True:
    # 가장 큰 수를 k번 더한다.
    for i in range(k):
        # 만약 m(더 해지는 횟수가 0이면 반복문 종료)
        if m == 0:
            break
            # m이 0아니라면 k번 만큼 first(제일 큰 값을 더한다)
        result += first
            # m번 의 횟수가 끝나면 종료되어야 하기 때문에 m은 --
        m -= 1
        # m번이 모두 수행되었다면 종료
    if m == 0:
        break
        # 남은 홧수 만큼 두번 째 큰값을 더한다.
    result += second
    # m이 0이 되면 종료 되어야 하기 때문에 m --
    m -= 1

print(result)
```

<br>

이 문제는 M이 10만 이하이므로 이 방식으로도 문제를 해결할 수 있지만 M의 크기가 100억이상처럼 커진다면 시간 초과 판정을 받을 것입니다. 간단한 수학적 아이디어를 이용해 더 효율적으로 문제를 해결해보겠습니다. 예를 들어 N이 5이고 입력 배열이 다음과 같다고 가정합니다.

<br>

[2, 4, 5, 4, 6]

<br>

이때 가장 큰 수와 두 번째로 큰수를 선택하면 6과 5가 됩니다.

이때 M이 8이고 K가 3이라면 다음과 같이 더했을 때 합을 최대로 할 수 있습니다.

(6 + 6 + 5) + (6 + 6 + 6 + 5)로 정답은 46이 됩니다.

<br>

이 문제를 풀기 위해선 **가장 먼저 반복되는 수열에 대해서 파악해야 합니다. 가장 큰 수와 두 번째로 큰 수가 더해질 때는 특정한 수열 형태로 일정하게 반복해서 더해지는 특징이 있습니다.**

위의 예시로는 {6,6,6,5} 가 반복이 됩니다. 그렇다면 반복되는 수열의 길이는 어떻게 될까요? 반복되는 수열의 길이는 (K + 1) 이 되는데 그 이유는 제일 큰 수 6이 가장 많이 나와야 하는데 한번에 3번까지만 허용이 되니 6을 3번 그리고 두번째 크기의 값을 1번 더한 후 다시 6을 더하는 것이 조건을 지키면서 가장 큰 숫자가 되는 경우이기 때문 입니다.

그리고 이 수열이 반복되는 횟수는 배열의 크기 M을 수열의 길이로 나눈 만큼 반복하게 됩니다.

그리고 여기서 가장 큰 데이터가 등장하는 횟수는 `M/(K+1) * K` 한 만큼 나오게 됩니다.

이때 주의할 점은 M이 (k+1)로 나누어떨어지지 않는 경우도 고려해야 합니다. **그럴 때는 M을 (k+1)로 나눈 나머지 만큼 가장 큰 수를 추가로 더해집니다.**

```python
int(M / (k+1)) * k + M % (k+1)
```

<br>

이를 활용한 두 번째 코드는 아래와 같습니다.

```python
n, m, k = map(int, input().split())
data = list(map(int, input().split()))

data.sort()
first = data[n - 1]
second = data[n - 2]

# 가장 큰 수가 더해지는 횟수 계산
count = int(m / (k + 1)) * k
count = count + m % (k+1)

result = 0
result += (count) * first
result += (m - count) * second

print(result)
```
